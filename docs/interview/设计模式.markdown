---
layout: default
title: 设计模式
nav_order: 2
parent: interview
---

![设计模式](../../../images/Interview/设计模式.jpg)

[设计模式七大原则及代码示例](https://www.cnblogs.com/lifegoeson/p/13456895.html)

## 单一职责

一个类或者一个接口，最好只负责一项职责。

## 开闭原则

一个软件实体如类、模版和函数应该对扩展开放，对修改关闭；

## 里氏替换原则

子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法； 
* 子类可以增加自己特有的方法； 
* 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更佳宽松； 
* 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更加严格；

## 依赖倒置原则

 低层模块尽量都要有抽象类或者接口，或者两者都有； 
* 变量的声明类型尽量是抽象类或者接口； 
* 使用继承时遵循里氏替换原则；

## 接口隔离原则

* 一个接口只服务于一个子模块或业务逻辑，服务定制； 
* 通过业务逻辑压缩接口中的public方法，让接口看起来更加精悍； 
* 已经被污染了的接口，尽量修改，如果变更风险太大，则用适配器模式进行转化； 
* 根据具体的业务，深入了解逻辑，用心感知去控制设计思路；

## 迪米特原则

定义：一个对象应该对其他对象保持最少的了解，其核心精神就是：不和陌生人说话，通俗之意就是一个对象对自己需要耦合关联调用的类应该知道的少；这会导致类之间的耦合度降低，每个类都尽量减少对其他类的依赖。


结构化程序设计的主要原则

1、自顶向下

　　程序设计时，应先考虑总体，后考虑细节；先考虑全局目标，后考虑局部目标。不要一开始就过多追求众多的细节，先从最上层总目标开始设计，逐步使问题具体化。

2、逐步求精

　　对复杂问题，应设计一些子目标作为过渡，逐步细化。

3、模块化

　　一个复杂问题，肯定是由若干稍简单的问题构成。模块化是把程序要解决的总目标分解为子目标，再进一步分解为具体的小目标，把每一个小目标称为一个模块。

4、限制使用goto语句

　　结构化程序设计方法的起源来自对GOTO语句的认识和争论。肯定的结论是：在块和进程的非正常出口处往往需要用GOTO语句，使用GOTO语句会使程序执行效率较高；在合成程序目标时，GOTO语句往往是有用的，如返回语句用GOTO。否定的结论是：GOTO语句是有害的，是造成程序混乱的祸根，程序的质量与GOTO语句的数量呈反比，应该在所有高级程序设计语言中取消GOTO语句。取消GOTO语句后，程序易于理解、易于排错、容易维护，容易进行正确性证明。作为争论的结论，1974年Knuth发表了令人信服的总结，并证实了：

GOTO语句确实有害，应当尽量避免；
完全避免使用GOTO语句也并非是个明智的方法，有些地方使用GOTO语句，会使程序流程更清楚、效率更高。
争论的焦点不应放在是否取消GOTO语句上，而应放在用什么样的程序结构上。其中最关键的是，应在以提高程序清晰性为目标的结构化方法中限制使用GOTO语句；
面向对象程序设计的主要原则

1、单一职责原则(Single-Responsibility Principle)　　

　　就一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因。所谓职责，我们可以理解为功能，就是设计的这个类功能应该只有一个，而不是两个或更多。也可以理解为引用变化的原因，当你发现有两个变化会要求我们修改这个类，那么你就要考虑撤分这个类了。因为职责是变化的一个轴线，当需求变化时，该变化会反映类的职责的变化。

　　优点：消除耦合，减小因需求变化引起代码僵化。

2、里氏代换原则(Liskov Substitution Principle)

　　子类型必须能够替换它们的基类型。一个软件实体如果使用的是一个基类，那么当把这个基类替换成继承该基类的子类，程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。

　　优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。

3、依赖倒置原则(Dependence Inversion Principle)

　　要依赖于抽象，不要依赖于具体，客户端依赖于抽象耦合；抽象不应依赖于细节，细节应依赖于抽象；要针对接口编程，不针对实现编程。

　　优点：使用传统过程化程序设计所创建的依赖关系，策略依赖于细节，这是糟糕的，因为策略受到细节改变的影响。依赖倒置原则使细节和策略都依赖于抽象，抽象的稳定性决定了系统的稳定性。

　　怎样做到依赖倒置？

以抽象方式耦合是依赖倒转原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且需要保证在任何引用到基类的地方都可以改换成其子类，因此，里氏代换原则是依赖倒转原则的基础。
在抽象层次上的耦合虽然有灵活性，但也带来了额外的复杂性，如果一个具体类发生变化的可能性非常小，那么抽象耦合能发挥的好处便十分有限，这时可以用具体耦合反而会更好。
　　层次化：所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供一组内聚的服务。

　　依赖于抽象：建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到：

任何变量都不应该持有一个指向具体类的指针或者引用；
任何类都不应该从具体类派生；
任何方法都不应该覆写它的任何基类中的已经实现的方法；
4、接口隔离原则(Interface Segregation Principle)

　　使用多个专一功能的接口比使用一个的总接口总要好。从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。

　　优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。

　　如何实现接口隔离原则？

利用委托分离接口；
利用多继承分离接口；
5、迪米特原则(Law of Demeter)

　　迪米特法则又叫做最少知识原则(Least Knowledge Principle或简写为LKP)，就是说，一个对象应当对其他对象有尽可能少的了解，对象与对象之间应使用尽可能少的方法来关联，避免千丝万缕的关系。

　　在软件系统中，一个模块设计的好不好的最主要、最重要的标志，就是该模块在多大的程度上将自己的内部数据和其他与实现有关的细节隐藏起来。一个设计好的模块可以将它所有的实现细节隐藏起来，彻底地将提供给外界的API和自己的实现分割开来。这样一来，模块与模块之间就可以仅仅通过彼此的API相互通信，而不理会模块内部的工作细节。这一概念就是“信息的隐藏”，或叫做“封装”，也就是大家熟悉的软件设计的基本教义之一。信息的隐藏非常重要的原因在于，它可以使各个子系统之间脱藕，从而允许它们独立地被开发、优化、使用、阅读以及修改。

　　如何实现迪米特法则？

　　迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点：

在类的划分上，应当创建有弱耦合的类，类之间的耦合越弱，就越有利于复用
在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。
在类的设计上，只要有可能，一个类应当设计成不变类
在对其它对象的引用上，一个类对其它对象的引用应该降到最低
对于顶级的类来说，只有两个可能的访问性等级：package-private和public，一个类可以设置成为package-private的，就不应该把它设置成为public的
谨慎使用Serializable：如果一个类实现了Serializable接口的话，客户端就可以将这个类串行后再并行化。假如以后这个类一旦修改，客户端势必也将改动。所以能不用就不用
6、开放－封闭原则(Open-Closed Principle)

　　对扩展开放，对修改关闭。

　　优点：按照OCP原则设计出来的系统，降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。

　　如何实现“开-闭”原则？

在面向对象设计中，不允许更改的是系统的抽象层，而允许扩展的是系统的实现层。
解决问题关键在于抽象化，抽象化是面向对象设计的第一个核心本质。对一个事物抽象化，即封装了事物的本质，看不到任何细节。
在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，不需更改，从而满足“对修改关闭”；而从抽象类导出的具体类可以改变系统的行为，从而满足“对扩展开放”。
对实体进行扩展时，不必改动软件的源代码或者二进制代码。
优秀程序设计的18大原则

1、避免重复原则(DRY - Don’t repeat yourself)

　　编程的最基本原则是避免重复。在程序代码中总会有很多结构体，如循环、函数、类等等。一旦你重复某个语句或概念，就很容易形成一个抽象体。

2、抽象原则(Abstraction Principle)

　　与DRY原则相关。要记住，程序代码中每一个重要的功能，只能出现在源代码的一个位置。

3、简单原则(Keep It Simple and Stupid)

　　简单是软件设计的目标，简单的代码占用时间少，漏洞少，并且易于修改。

4、避免创建你不要的代码(Avoid Creating a YAGNI (You aren’t going to need it))

　　除非你需要它，否则别创建新功能。

5、尽可能做可运行的最简单的事(Do the simplest thing that could possibly work)

　　尽可能做可运行的最简单的事。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢?”这将有助于在设计中保持简单的路径。

6、别让我思考(Don’t make me think)

　　这是Steve Krug一本书的标题，同时也和编程有关。所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。

7、开闭原则(Open/Closed Principle)

　　你所编写的软件实体(类、模块、函数等)最好是开源的，这样别人可以拓展开发。不过，对于你的代码，得限定别人不得修改。换句话说，别人可以基于你的代码进行拓展编写，但却不能修改你的代码。

8、代码维护(Write Code for the Maintainer)

　　一个优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。用书中原话说“如果一个维护者不再继续维护你的代码，很可能他就有想杀了你的冲动。”

9、最小惊讶原则(Principle of least astonishment)

　　最小惊讶原则通常是在用户界面方面引用，但同样适用于编写的代码。代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。

10、单一责任原则(Single Responsibility Principle)

　　某个代码的功能，应该保证只有单一的明确的执行任务。

11、低耦合原则(Minimize Coupling)

　　代码的任何一个部分应该减少对其他区域代码的依赖关系。尽量不要使用共享参数。低耦合往往是完美结构系统和优秀设计的标志。

12、最大限度凝聚原则(Maximize Cohesion)

　　相似的功能代码应尽量放在一个部分。

13、隐藏实现细节(Hide Implementation Details)

　　隐藏实现细节原则，当其他功能部分发生变化时，能够尽可能降低对其他组件的影响。

14、迪米特法则又叫作最少知识原则(Law of Demeter)

　　该代码只和与其有直接关系的部分连接。(比如：该部分继承的类，包含的对象，参数传递的对象等)。

15、避免过早优化(Avoid Premature Optimization)

　　除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。

　　“过早的优化是一切罪恶的根源”——Donald Knuth

16、代码重用原则(Code Reuse is Good)

　　重用代码能提高代码的可读性，缩短开发时间。

17、关注点分离(Separation of Concerns)

　　不同领域的功能，应该由不同的代码和最小重迭的模块组成。

18、拥抱改变(Embrace Change)

　　这是Kent Beck一本书的标题，同时也被认为是极限编程和敏捷方法的宗旨。